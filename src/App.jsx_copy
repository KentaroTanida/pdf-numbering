import React, { useRef, useState } from "react";
import { PDFDocument, StandardFonts, rgb, degrees } from "pdf-lib";
import fontkit from "@pdf-lib/fontkit";

// ローカル同梱フォント（public/fonts/ 配下）
const DEFAULT_JP_FONT_URL = "/fonts/NotoSansJP-Medium.ttf";

export default function App() {
  const fileRef = useRef(null);
  const [pdfName, setPdfName] = useState("");
  const [processing, setProcessing] = useState(false);

  // Controls
  const [text, setText] = useState("CONFIDENTIAL");
  // 初期の“パターン”を復活 + 拡張
  // tile: 繰り返し（水平/垂直）
  // diagonal-big: 大きく1つを斜めに
  // diagonal-tile: 斜め方向に繰り返し
  // center: 中央に1つ
  const [mode, setMode] = useState("tile");
  const [angle, setAngle] = useState(45); // degrees
  const [fontSize, setFontSize] = useState(48);
  const [color, setColor] = useState("#d00000");
  const [opacity, setOpacity] = useState(0.15); // 0..1
  const [xSpacing, setXSpacing] = useState(180);
  const [ySpacing, setYSpacing] = useState(160);
  const [margin, setMargin] = useState(24);
  const [firstPageOnly, setFirstPageOnly] = useState(false);

  // フォント取得方式（自動読み込み + フォールバック）
  const [fontUrl, setFontUrl] = useState(DEFAULT_JP_FONT_URL);

  async function addWatermark() {
    const file = fileRef.current?.files?.[0];
    if (!file) {
      alert("PDFを選択してください。");
      return;
    }
    setProcessing(true);
    try {
      const arrayBuffer = await file.arrayBuffer();
      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });

      // fontkit を登録
      pdfDoc.registerFontkit(fontkit);

      // 日本語フォントを取得（失敗時は Helvetica にフォールバック）
      let font;
      try {
        const res = await fetch(fontUrl);
        if (!res.ok) throw new Error("font fetch failed");
        const bytes = await res.arrayBuffer();
        font = await pdfDoc.embedFont(bytes, { subset: true });
      } catch (e) {
        console.warn("Japanese font fetch failed. Fallback to StandardFonts.Helvetica", e);
        font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      }

      const colorRgb = hexToRgb(color);
      const pages = firstPageOnly ? [pdfDoc.getPages()[0]] : pdfDoc.getPages();

      for (const page of pages) {
        const { width, height } = page.getSize();

        if (mode === "center") {
          const textWidth = font.widthOfTextAtSize(text, fontSize);
          const textHeight = fontSize;
          page.drawText(text, {
            x: (width - textWidth) / 2,
            y: (height - textHeight) / 2,
            size: fontSize,
            font,
            color: rgb(colorRgb.r / 255, colorRgb.g / 255, colorRgb.b / 255),
            rotate: degrees(angle),
            opacity,
          });
        } else if (mode === "diagonal-big") {
          // ページ対角線の 75% で自動サイズ
          const diag = Math.sqrt(width * width + height * height);
          const factor = 0.75;
          const size = Math.max(16, (factor * diag) / Math.max(4, text.length));
          const w = font.widthOfTextAtSize(text, size);
          const h = size;
          page.drawText(text, {
            x: (width - w) / 2,
            y: (height - h) / 2,
            size,
            font,
            color: rgb(colorRgb.r / 255, colorRgb.g / 255, colorRgb.b / 255),
            rotate: degrees(angle),
            opacity,
          });
        } else if (mode === "tile") {
          drawTiled(page, { font, text, fontSize, colorRgb, opacity, angle, xSpacing, ySpacing, margin });
        } else if (mode === "diagonal-tile") {
          // 斜め方向のタイル：回転をかけたまま全体を敷き詰める
          drawTiled(page, { font, text, fontSize, colorRgb, opacity, angle, xSpacing, ySpacing, margin, stagger: true });
        }
      }

      const bytes = await pdfDoc.save({ addDefaultPage: false });
      const blob = new Blob([bytes], { type: "application/pdf" });
      const outName = makeOutName(file.name || pdfName || "watermarked.pdf");
      triggerDownload(blob, outName);
    } catch (e) {
      console.error(e);
      alert("透かしの追加でエラーが発生しました。コンソールを確認してください。");
    } finally {
      setProcessing(false);
    }
  }

  return (
    <div className="min-h-screen bg-gray-50 text-gray-900 flex">
      {/* 左右スペース（広告枠想定。空白のまま） */}
      <div className="hidden lg:flex w-40"></div>
      <div className="flex-1 w-full">
        <header className="sticky top-0 z-10 bg-white/80 backdrop-blur border-b">
          <div className="px-4 py-3 flex items-center justify-between">
            <h1 className="text-xl font-semibold">PDF Watermarker</h1>
            <a
              className="text-sm underline opacity-80 hover:opacity-100"
              href="https://pdf-lib.js.org/"
              target="_blank" rel="noreferrer"
            >Powered by pdf-lib</a>
          </div>
        </header>
        <main className="px-4 py-6 w-full">
          <div className="grid md:grid-cols-3 gap-6">
            <section className="md:col-span-1 space-y-4">
              <div className="p-4 bg-white rounded-2xl shadow">
                <label className="block text-sm font-medium mb-1">PDF ファイル</label>
                <input
                  ref={fileRef}
                  type="file"
                  accept="application/pdf"
                  onChange={(e)=> setPdfName(e.target.files?.[0]?.name || "")}
                  className="block w-full text-sm file:mr-3 file:rounded-lg file:border file:px-3 file:py-2 file:bg-gray-50 file:hover:bg-gray-100"
                />
                <p className="text-xs text-gray-500 mt-1 truncate">{pdfName}</p>
              </div>

              <div className="p-4 bg-white rounded-2xl shadow space-y-3">
                <div>
                  <label className="block text-sm font-medium mb-1">透かし文字</label>
                  <input
                    className="w-full rounded-lg border px-3 py-2"
                    value={text}
                    onChange={(e)=> setText(e.target.value)}
                  />
                </div>

                {/* 復活したパターン選択 */}
                <div>
                  <label className="block text-sm font-medium mb-1">パターン</label>
                  <div className="grid grid-cols-2 gap-2 text-sm">
                    <ModeButton label="繰り返し（タイル）" active={mode==="tile"} onClick={()=> setMode("tile")} />
                    <ModeButton label="斜め（大）" active={mode==="diagonal-big"} onClick={()=> setMode("diagonal-big")} />
                    <ModeButton label="斜め（繰り返し）" active={mode==="diagonal-tile"} onClick={()=> setMode("diagonal-tile")} />
                    <ModeButton label="中央（1個）" active={mode==="center"} onClick={()=> setMode("center")} />
                  </div>
                </div>

                <div className="grid grid-cols-2 gap-3">
                  <LabeledNumber label="角度(°)" value={angle} setValue={setAngle} min={-180} max={180} />
                  <LabeledNumber label="フォントサイズ" value={fontSize} setValue={setFontSize} min={8} max={400} />
                  <LabeledNumber label="X間隔" value={xSpacing} setValue={setXSpacing} min={40} max={800} />
                  <LabeledNumber label="Y間隔" value={ySpacing} setValue={setYSpacing} min={40} max={800} />
                  <LabeledNumber label="余白" value={margin} setValue={setMargin} min={0} max={200} />
                </div>

                {/* フォントURL（ローカル同梱を既定。必要に応じて変更可） */}
                <div className="space-y-1 text-xs text-gray-600">
                  <label className="block font-medium">日本語フォントURL</label>
                  <input
                    className="w-full rounded-lg border px-3 py-2 text-xs"
                    value={fontUrl}
                    onChange={(e)=> setFontUrl(e.target.value)}
                  />
                  <p>※ 既定は <code className="bg-gray-100 px-1 rounded">/fonts/NotoSansJP-Regular.ttf</code>（<code>public/fonts/</code>に配置）</p>
                </div>

                <div>
                  <label className="inline-flex items-center gap-2 text-sm">
                    <input type="checkbox" checked={firstPageOnly} onChange={(e)=> setFirstPageOnly(e.target.checked)} />
                    1ページ目のみ
                  </label>
                </div>

                <button
                  onClick={addWatermark}
                  disabled={processing}
                  className="mt-2 w-full rounded-xl bg-black text-white py-2.5 disabled:opacity-60"
                >{processing ? "処理中..." : "PDFに透かしを追加"}</button>
              </div>

              <Tips />
            </section>

            <section className="md:col-span-2">
              <div className="p-6 bg-white rounded-2xl shadow">
                <h2 className="text-lg font-semibold mb-3">使い方</h2>
                <ol className="list-decimal pl-5 space-y-2 text-sm">
                  <li>左上の「PDFファイル」を選択します。</li>
                  <li>透かし文字やパターンを選び、角度・色・不透明度・間隔などを設定します。</li>
                  <li>「PDFに透かしを追加」をクリックすると、加工済みPDFがダウンロードされます。</li>
                </ol>
                <p className="text-xs text-gray-500 mt-4">すべての処理はブラウザ内で行われ、ファイルはサーバに送信されません。</p>
              </div>
            </section>
          </div>
        </main>
      </div>
      {/* 右側スペース */}
      <div className="hidden lg:flex w-40"></div>
    </div>
  );
}

function ModeButton({ label, active, onClick }) {
  return (
    <button
      onClick={onClick}
      className={`px-3 py-1.5 rounded-lg border text-sm ${active ? "bg-gray-900 text-white" : "bg-white hover:bg-gray-50"}`}
    >{label}</button>
  );
}

function LabeledNumber({ label, value, setValue, min=0, max=9999 }) {
  return (
    <label className="block text-sm">
      <span className="font-medium">{label}</span>
      <input
        type="number"
        className="w-full mt-1 rounded-lg border px-3 py-2"
        value={value}
        min={min}
        max={max}
        onChange={(e)=> setValue(Number(e.target.value))}
      />
    </label>
  );
}

function Tips() {
  return (
    <div className="p-4 bg-white rounded-2xl shadow mt-4 text-xs text-gray-600 space-y-2">
      <div className="font-semibold text-gray-800">ヒント</div>
      <ul className="list-disc pl-5 space-y-1">
        <li>大きなPDFは処理に時間がかかる場合があります。必要なら「1ページ目のみ」を試してから全ページに適用してください。</li>
        <li>「斜め（繰り返し）」は角度・間隔を調整すると均等に敷き詰めやすくなります。</li>
        <li>タイル時は行を半ピッチずらすことで視認性を上げています。余白で端のはみ出しを調整可能です。</li>
      </ul>
    </div>
  );
}

function drawTiled(page, { font, text, fontSize, colorRgb, opacity, angle, xSpacing, ySpacing, margin, stagger = true }) {
  const { width, height } = page.getSize();
  const stepX = Math.max(40, xSpacing);
  const stepY = Math.max(40, ySpacing);
  for (let y = -stepY; y < height + stepY; y += stepY) {
    for (let x = -stepX; x < width + stepX; x += stepX) {
      const xOffset = stagger && (Math.floor(y / stepY) % 2 !== 0) ? stepX / 2 : 0;
      page.drawText(text, {
        x: x + xOffset + margin,
        y: y + margin,
        size: fontSize,
        font,
        color: rgb(colorRgb.r / 255, colorRgb.g / 255, colorRgb.b / 255),
        rotate: degrees(angle),
        opacity,
      });
    }
  }
}

function triggerDownload(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function makeOutName(name) {
  if (!name?.toLowerCase().endsWith(".pdf")) return `${name || "document"}-watermarked.pdf`;
  const base = name.slice(0, -4);
  return `${base}-watermarked.pdf`;
}

function hexToRgb(hex) {
  const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (!m) return { r: 0, g: 0, b: 0 };
  return {
    r: parseInt(m[1], 16),
    g: parseInt(m[2], 16),
    b: parseInt(m[3], 16),
  };
}